import OpenAI from 'openai';
import config from '../config/index.js';
import { getModelConfig } from '../config/models.js';

const openai = new OpenAI({
  apiKey: config.openai.apiKey
});

/**
 * QA Agent Service
 * 
 * Monitors and validates prompts generated by the main agent
 * Checks for:
 * - Adherence to prompt rules and structure
 * - Logical parameter selection
 * - Model compatibility
 * - Use of user feedback (comments)
 * - Proper weight application
 */

/**
 * Validate a prompt generated by the main agent
 * 
 * @param {Object} promptData - The prompt generation data
 * @param {string} promptData.userPrompt - Original user prompt
 * @param {string} promptData.enhancedPrompt - Agent-generated prompt
 * @param {Object} promptData.selectedParams - Selected parameters
 * @param {string} promptData.agentType - 'dating' or 'general'
 * @param {string} promptData.model - Model to be used for generation
 * @param {Array} promptData.recentComments - Recent user comments
 * @param {string} promptData.category - Content category
 * @returns {Object} Validation result with feedback
 */
export async function validatePrompt(promptData) {
  try {
    console.log('\n' + '='.repeat(80));
    console.log('üîç QA AGENT - VALIDATING PROMPT');
    console.log('='.repeat(80));
    console.log('Agent type:', promptData.agentType);
    console.log('Model:', promptData.model);
    console.log('Category:', promptData.category);
    
    // Get model configuration for compatibility check
    const modelConfig = getModelConfig('image', promptData.model);
    
    if (!modelConfig) {
      console.warn('‚ö†Ô∏è  Unknown model:', promptData.model);
    }
    
    // Build validation prompt based on agent type
    const systemPrompt = getQASystemPrompt(promptData.agentType, modelConfig);
    const validationPrompt = buildValidationPrompt(promptData, modelConfig);
    
    console.log('ü§ñ Calling GPT-4o for QA validation...');
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: validationPrompt }
      ],
      max_tokens: 3000,
      temperature: 0.3, // Lower temperature for consistent validation
      response_format: { type: "json_object" }
    });
    
    const result = JSON.parse(response.choices[0].message.content);
    
    console.log('‚úÖ QA validation complete');
    console.log('Status:', result.status);
    console.log('Score:', result.score, '/100');
    console.log('Issues found:', result.issues?.length || 0);
    console.log('='.repeat(80) + '\n');
    
    return {
      success: true,
      validation: result,
      model: 'gpt-4o',
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('‚ùå QA validation error:', error);
    return {
      success: false,
      error: error.message,
      validation: {
        status: 'error',
        score: 0,
        issues: [{ type: 'system_error', message: error.message }]
      }
    };
  }
}

/**
 * Get QA system prompt based on agent type
 */
function getQASystemPrompt(agentType, modelConfig) {
  const basePrompt = `You are a Quality Assurance AI agent that validates prompts generated by other AI agents.

üéØ YOUR ROLE:
Analyze the generated prompt and provide detailed feedback on quality, adherence to rules, and model compatibility.

üìã OUTPUT FORMAT (JSON):
{
  "status": "approved" | "needs_revision" | "rejected",
  "score": <number 0-100>,
  "issues": [
    {
      "type": "parameter_error" | "structure_error" | "model_incompatibility" | "missing_feedback" | "logic_error" | "other",
      "severity": "critical" | "major" | "minor",
      "message": "Description of the issue",
      "suggestion": "How to fix it"
    }
  ],
  "strengths": ["List of things done well"],
  "modelCompatibility": {
    "compatible": true/false,
    "reason": "Why or why not",
    "suggestions": ["Model-specific improvements"]
  },
  "feedbackUsage": {
    "commentsUsed": true/false,
    "weightsApplied": true/false,
    "userPreferencesConsidered": true/false
  },
  "overallFeedback": "Summary and recommendations"
}`;

  if (agentType === 'dating') {
    return basePrompt + `

üîç DATING-SPECIFIC VALIDATION RULES:

1. **SMARTPHONE AUTHENTICITY** (Critical)
   - MUST include filename (IMG_####.HEIC, DSC_####.JPG, etc.)
   - MUST specify device (iPhone 13/14 Pro, Pixel 7, Samsung S21)
   - MUST NOT use technical jargon (no "aperture", "bokeh", "diffusion")
   - MUST sound like natural description

2. **IMPERFECTIONS** (Critical)
   - MUST include 1-3 authentic flaws
   - Examples: slight off-center, tiny motion blur, casual angle
   - MUST NOT be perfect/overly polished

3. **11-PARAMETER COVERAGE**
   - Should cover major categories: subject, composition, background, lighting, color, mood, motion, depth, texture, time/weather
   - Not all 11 required, but major ones should be present

4. **NATURAL LANGUAGE**
   - No technical photography terms
   - Flows like natural description
   - Casual, authentic feel

5. **MODEL COMPATIBILITY**
   - Seedream 4: Perfect for smartphone realism
   - Nano Banana Pro: Good, supports realistic photos
   - FLUX models: May struggle with specific filename/device authenticity
   - SDXL: Less suitable for ultra-realistic smartphone feel

6. **FEEDBACK INTEGRATION**
   - If user comments mention "too perfect" ‚Üí add more imperfections
   - If user likes "natural lighting" ‚Üí emphasize in prompt
   - Weight patterns should influence parameter selection`;
  } else if (agentType === 'ad-replicator') {
    return basePrompt + `

üîç AD CREATIVE REPLICATOR VALIDATION RULES:

1. **PROMPT LENGTH** (Critical)
   - MUST be 200-400 words
   - NOT short (50-100 words)
   - Detailed, photographer-style description

2. **COLOR SPECIFICATIONS** (Critical)
   - MUST include hex codes (#FF5733, #2C3E50, etc.)
   - Specify exact brand colors
   - Match reference image palette

3. **TEXT OVERLAYS** (Critical)
   - MUST specify all text word-for-word
   - Headlines, body copy, CTA buttons
   - Exact placement and formatting

4. **TECHNICAL SPECS** (Critical)
   - Resolution: 2K or 4K explicitly stated
   - Aspect ratio: Usually 1:1 for ad creatives
   - Image quality: "high resolution", "professional quality"

5. **LAYOUT & COMPOSITION** (Required)
   - Describe exact layout from reference
   - Element positioning (top-left, center, etc.)
   - Visual hierarchy and balance

6. **CONVERSION ELEMENTS** (Required)
   - CTA preserved from reference
   - Benefits/features highlighted
   - Trust signals (testimonials, guarantees, etc.)

7. **NICHE ADAPTATION** (Required)
   - Tailored to specific niche (Dating, Teeth Whitening, etc.)
   - Niche-specific language and imagery
   - Target audience considerations

8. **MODEL COMPATIBILITY**
   - Nano Banana Pro: BEST for ad creatives with text
   - Seedream 4: Good for realistic product shots
   - FLUX Dev: Alternative for detailed text
   - SDXL: Less suitable for legible text

9. **CREATIVE STRATEGY** (Required)
   - Replicate winning strategy, not pixels
   - Maintain psychological hooks
   - Preserve competitive advantages

10. **ORIGINALITY** (Critical)
   - MUST generate NEW imagery
   - NOT copy/paste competitor visuals
   - Fresh take on winning patterns`;
  } else {
    return basePrompt + `

üîç GENERAL CONTENT VALIDATION RULES:

1. **DETAIL & SPECIFICITY**
   - Prompt should be detailed and specific
   - Clear description of what to generate
   - Appropriate level of detail for the content type

2. **PARAMETER LOGIC**
   - Parameters should be logically consistent
   - No contradictions (e.g., "dark scene" + "bright sunlight")
   - Parameters should complement each other

3. **CREATIVITY & VARIETY**
   - Prompt should offer something interesting
   - Not generic or boring
   - Appropriate creativity for the request

4. **CATEGORY ADAPTATION**
   - Prompt should fit the category (cars, nature, architecture, etc.)
   - Category-specific details included
   - Appropriate style for the subject

5. **MODEL COMPATIBILITY**
   - Seedream 4: Good for most realistic content
   - Nano Banana Pro: Excellent for detailed, legible text
   - FLUX Schnell: Fast, general purpose
   - FLUX Dev: High detail, complex scenes
   - SDXL: Artistic, stylized content

6. **FEEDBACK INTEGRATION**
   - User comments should influence prompt direction
   - Weighted parameters should be reflected
   - Previous preferences considered`;
  }
}

/**
 * Build validation prompt with all context
 */
function buildValidationPrompt(promptData, modelConfig) {
  const {
    userPrompt,
    enhancedPrompt,
    selectedParams,
    agentType,
    model,
    recentComments,
    category
  } = promptData;
  
  let prompt = `Validate this AI-generated prompt:

**AGENT TYPE**: ${agentType}
**CATEGORY**: ${category}
**MODEL**: ${model} (${modelConfig?.name || 'Unknown'})

**USER'S ORIGINAL REQUEST**:
"${userPrompt}"

**AGENT'S GENERATED PROMPT**:
"${enhancedPrompt}"

**SELECTED PARAMETERS**:
${JSON.stringify(selectedParams, null, 2)}`;

  if (recentComments && recentComments.length > 0) {
    prompt += `\n\n**RECENT USER FEEDBACK** (Last ${recentComments.length} comments):
${recentComments.map((c, i) => `${i + 1}. [Rating: ${c.rating}] ${c.comment || 'No comment'}`).join('\n')}`;
  } else {
    prompt += `\n\n**RECENT USER FEEDBACK**: None available`;
  }

  if (modelConfig) {
    prompt += `\n\n**MODEL SPECIFICATIONS**:
- Name: ${modelConfig.name}
- Speed: ${modelConfig.speed}
- Price: ${modelConfig.price}
- Strengths: ${modelConfig.description}`;
  }

  prompt += `\n\nPerform comprehensive QA validation and provide feedback in JSON format.`;

  return prompt;
}

/**
 * Quick validation - lighter check without full analysis
 * Useful for batch validation or real-time checking
 * 
 * ENHANCED VERSION (2025-12-09):
 * - Word count validation (200-400 words for detailed prompts)
 * - Hex color code detection (#RRGGBB)
 * - Resolution keywords (2K, 4K, 1080p, etc.)
 * - Text overlay detection for Ad Replicator
 */
export async function quickValidate(enhancedPrompt, agentType, model) {
  try {
    const modelConfig = getModelConfig('image', model);
    
    // Simple rule-based checks
    const issues = [];
    
    // Word count validation (200-400 words for detailed prompts)
    const wordCount = enhancedPrompt.trim().split(/\s+/).length;
    if (agentType === 'ad-replicator') {
      if (wordCount < 200) {
        issues.push({
          type: 'structure_error',
          severity: 'critical',
          message: `Ad Replicator prompt too short (${wordCount} words, need 200-400)`
        });
      } else if (wordCount > 400) {
        issues.push({
          type: 'structure_error',
          severity: 'minor',
          message: `Ad Replicator prompt very long (${wordCount} words, recommended 200-400)`
        });
      }
    }
    
    // Dating-specific quick checks
    if (agentType === 'dating') {
      // Check for filename
      if (!enhancedPrompt.match(/IMG_\d{4}|DSC_\d{4}|CR2/i)) {
        issues.push({
          type: 'structure_error',
          severity: 'critical',
          message: 'Missing smartphone filename (IMG_####.HEIC, etc.)'
        });
      }
      
      // Check for technical jargon
      const jargon = ['aperture', 'bokeh', 'diffusion', 'f-stop', 'focal length', 'shutter speed'];
      const foundJargon = jargon.filter(term => enhancedPrompt.toLowerCase().includes(term));
      if (foundJargon.length > 0) {
        issues.push({
          type: 'structure_error',
          severity: 'major',
          message: `Technical jargon detected: ${foundJargon.join(', ')}`
        });
      }
      
      // Check for imperfections keywords
      const imperfectionKeywords = ['slight', 'subtle', 'casual', 'off-center', 'blur', 'imperfect', 'natural'];
      const hasImperfections = imperfectionKeywords.some(keyword => 
        enhancedPrompt.toLowerCase().includes(keyword)
      );
      if (!hasImperfections) {
        issues.push({
          type: 'parameter_error',
          severity: 'major',
          message: 'Missing authentic imperfections (needs slight blur, off-center, etc.)'
        });
      }
    }
    
    // Ad Replicator specific checks
    if (agentType === 'ad-replicator') {
      // Check for hex color codes
      const hexColors = enhancedPrompt.match(/#[0-9A-Fa-f]{6}/g);
      if (!hexColors || hexColors.length === 0) {
        issues.push({
          type: 'parameter_error',
          severity: 'major',
          message: 'Missing hex color codes (e.g., #FF5733). Ad creatives need specific colors.'
        });
      }
      
      // Check for resolution keywords
      const resolutionKeywords = ['2k', '4k', '1080p', '2160p', 'high resolution', 'hd', 'uhd'];
      const hasResolution = resolutionKeywords.some(keyword => 
        enhancedPrompt.toLowerCase().includes(keyword)
      );
      if (!hasResolution) {
        issues.push({
          type: 'parameter_error',
          severity: 'major',
          message: 'Missing resolution specification (2K, 4K, etc.)'
        });
      }
      
      // Check for text overlay mentions
      const textKeywords = ['text:', 'headline:', 'copy:', 'cta:', 'button:', 'overlay text'];
      const hasTextOverlay = textKeywords.some(keyword => 
        enhancedPrompt.toLowerCase().includes(keyword)
      );
      if (!hasTextOverlay) {
        issues.push({
          type: 'parameter_error',
          severity: 'major',
          message: 'Missing text overlay specification. Ad creatives need explicit text/headline.'
        });
      }
    }
    
    // General checks
    if (enhancedPrompt.length < 50) {
      issues.push({
        type: 'structure_error',
        severity: 'critical',
        message: 'Prompt too short (less than 50 characters)'
      });
    }
    
    if (enhancedPrompt.length > 3000) {
      issues.push({
        type: 'structure_error',
        severity: 'minor',
        message: 'Prompt very long (over 3000 characters)'
      });
    }
    
    const score = Math.max(0, 100 - (issues.length * 15));
    const status = score >= 70 ? 'approved' : score >= 50 ? 'needs_revision' : 'rejected';
    
    return {
      success: true,
      validation: {
        status,
        score,
        issues,
        quickCheck: true,
        wordCount, // Added for debugging
        agentType // Added for debugging
      }
    };
    
  } catch (error) {
    console.error('Quick validation error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

export default {
  validatePrompt,
  quickValidate
};
