import express from 'express';
import { validatePrompt, quickValidate } from '../services/qa-agent.service.js';
import { supabase } from '../db/supabase.js';

const router = express.Router();

/**
 * POST /api/qa/validate
 * Validate a prompt generated by the main agent
 * 
 * Body: {
 *   userPrompt: string,
 *   enhancedPrompt: string,
 *   selectedParams: Object,
 *   agentType: 'dating' | 'general',
 *   model: string,
 *   category: string,
 *   sessionId?: string (optional, for fetching recent comments)
 * }
 */
router.post('/validate', async (req, res) => {
  try {
    const {
      userPrompt,
      enhancedPrompt,
      selectedParams,
      agentType,
      model,
      category,
      sessionId
    } = req.body;
    
    console.log('\n' + '='.repeat(80));
    console.log('üîç QA VALIDATION REQUEST');
    console.log('='.repeat(80));
    console.log('Agent type:', agentType);
    console.log('Model:', model);
    console.log('Session ID:', sessionId || 'None');
    
    // Validation
    if (!userPrompt || !enhancedPrompt || !agentType || !model) {
      return res.status(400).json({
        success: false,
        error: 'userPrompt, enhancedPrompt, agentType, and model are required'
      });
    }
    
    // Fetch recent comments if sessionId provided
    let recentComments = [];
    if (sessionId) {
      const { data: comments, error: commentsError } = await supabase
        .from('content_v3')
        .select('rating, comment')
        .eq('session_id', sessionId)
        .not('rating', 'is', null)
        .not('comment', 'is', null)
        .order('created_at', { ascending: false })
        .limit(10);
      
      if (!commentsError && comments) {
        recentComments = comments;
        console.log('üìù Loaded', comments.length, 'recent comments for context');
      }
    }
    
    // Build prompt data
    const promptData = {
      userPrompt,
      enhancedPrompt,
      selectedParams: selectedParams || {},
      agentType,
      model,
      category: category || 'general',
      recentComments
    };
    
    // Validate
    const result = await validatePrompt(promptData);
    
    if (!result.success) {
      throw new Error(result.error);
    }
    
    console.log('‚úÖ Validation complete');
    console.log('Status:', result.validation.status);
    console.log('='.repeat(80) + '\n');
    
    res.json({
      success: true,
      data: result
    });
    
  } catch (error) {
    console.error('‚ùå QA validation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * POST /api/qa/quick-validate
 * Quick validation without full AI analysis
 * Useful for real-time checking during generation
 * 
 * Body: {
 *   enhancedPrompt: string,
 *   agentType: 'dating' | 'general',
 *   model: string
 * }
 */
router.post('/quick-validate', async (req, res) => {
  try {
    const { enhancedPrompt, agentType, model } = req.body;
    
    if (!enhancedPrompt || !agentType || !model) {
      return res.status(400).json({
        success: false,
        error: 'enhancedPrompt, agentType, and model are required'
      });
    }
    
    console.log('‚ö° Quick validation:', agentType, model);
    
    const result = await quickValidate(enhancedPrompt, agentType, model);
    
    if (!result.success) {
      throw new Error(result.error);
    }
    
    res.json({
      success: true,
      data: result
    });
    
  } catch (error) {
    console.error('‚ùå Quick validation error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

/**
 * GET /api/qa/stats
 * Get QA statistics for a session
 * Shows how many prompts passed/failed validation
 * 
 * Query params:
 *   sessionId: string (required)
 */
router.get('/stats', async (req, res) => {
  try {
    const { sessionId } = req.query;
    
    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: 'sessionId is required'
      });
    }
    
    // For now, return placeholder stats
    // In a full implementation, you'd store QA results in a database table
    res.json({
      success: true,
      data: {
        sessionId,
        totalValidations: 0,
        approved: 0,
        needsRevision: 0,
        rejected: 0,
        averageScore: 0,
        message: 'QA stats tracking not yet implemented. Use /validate endpoint to validate prompts.'
      }
    });
    
  } catch (error) {
    console.error('‚ùå QA stats error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

export default router;
